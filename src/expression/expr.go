package main

import (
	"errors"
	"fmt"
	"reflect"
)

//
//func main() {
//	env := map[string]interface{}{
//		"greet":   "Hello, %v",
//		"data":    "你好#root.Name还有#current",
//		"names":   []string{"world", "you"},
//		"sprintf": fmt.Sprintf,
//		"println": fmt.Print,
//		"fun_Test1": fun.Test1,
//		"root":    Data{Name: "nihao", Age: 21},
//		"current": 12,
//	}
//
//	//code := `sprintf("你%v好%v还有", root.Name, current)`
//	//code := `sprintf("名字%v不合法，还有当前的值%v不满足要求，还有%v is not Empty", root.Age, current, root.Name)`
//	////code := "名字#root.Age不合法，还有当前的值#current不满足要求，还有#root.Name is not Empty"
//	code := `fun_Test1("zhou")`
//
//	//errMsg := errMsgChange(code)
//
//	//fmt.Println(errMsg)
//
//	tree, err := parser.Parse(code)
//	if err != nil {
//		panic(err)
//	}
//
//	program, err := compiler.Compile(tree, nil)
//	if err != nil {
//		panic(err)
//	}
//
//	output, err := expr.Run(program, env)
//	if err != nil {
//		panic(err)
//	}
//
//	fmt.Println(output)
//	//fmt.Println(program.Disassemble())
//
//	//fmt.Println(fun.Test1("zhou"))
//
//
//	name := runtime.FuncForPC(reflect.ValueOf(main).Pointer()).Name()
//	fmt.Println("Name of function : " + name)
//
//
//	test1()
//}
//
//
//type S1 interface{}
//type S2 interface{}
//func Format(name string, company S1, level S2, age int) {
//	fmt.Printf("name ＝ %s, company=%s, level=%s, age ＝ %d!\n", name, company, level, age)
//}
//func test1() {
//	//控制实例的创建
//	inj := inject.New()
//	//实参注入
//	inj.Map("tom")
//	inj.MapTo("tencent", (*S1)(nil))
//	inj.MapTo("T4", (*S2)(nil))
//	inj.Map(23)
//	//函数反转调用
//	inj.Invoke("Format")
//}
//
//type Data struct {
//	Name string
//	Age  int
//}

// 数据#root.Age的名字#current不合法
// sprintf("数据%v的名字%v不合法", root.Age, current)
//func chg(str string) string {
//
//}

//func TestRun_fast_methods(t *testing.T) {
//	input := `hello() + world()`
//
//	tree, err := parser.Parse(input)
//	require.NoError(t, err)
//
//	env := map[string]interface{}{
//		"hello": func(...interface{}) interface{} { return "hello " },
//		"world": func(...interface{}) interface{} { return "world" },
//	}
//	funcConf := conf.New(env)
//	_, err = checker.Check(tree, funcConf)
//	require.NoError(t, err)
//
//	program, err := compiler.Compile(tree, funcConf)
//	require.NoError(t, err)
//
//	out, err := vm.Run(program, env)
//	require.NoError(t, err)
//
//	require.Equal(t, "hello world", out)
//}

func check(e error) {
	if e != nil {
		panic(e)
	}
}

type NameType struct {
}

func (nameType *NameType) fl(name string) (bool, string) {
	return name == "zhou", ""
}

func fl(name string) (bool, string) {
	return name == "zhou", ""
}
func f2() {
	println("f2")
}

//var funMap = make(map[string]fun())

func Fun1(name string) bool {
	return name == "zhou"
}

func main() {
	test2()
}

func test(name string) string {
	return "hello " + name
}

func Call1(m map[string]interface{}, name string, params ...interface{}) ([]reflect.Value, error) {
	fv := reflect.ValueOf(m[name])
	if fv.Kind() != reflect.Func {
		return nil, errors.New("the value of key is not a function")
	}
	if len(params) != 1 {
		return nil, errors.New("argument passed in does not match the function")
	}
	in := make([]reflect.Value, len(params))
	for i, param := range params {
		in[i] = reflect.ValueOf(param)
	}
	return fv.Call(in), nil
}

func test2() {
	m := make(map[string]interface{})
	m["test"] = test
	result, err := Call1(m, "test", "rarnu")
	if err != nil {
		panic(err)
	}
	retstr := result[0].String()
	fmt.Println(retstr)
}

func test1() {
	//var data string
	//echo := func(s string, xs ...interface{}) {
	//	data += fmt.Sprintf(s, xs...) + "\n"
	//}
	//
	//echo(`// Code generated by vm/generate/main.go. DO NOT EDIT.`)
	//echo(``)
	//echo(`package fun`)
	////echo(`import (`)
	////echo(`"fmt"`)
	////echo(`"reflect"`)
	////echo(`)`)
	//
	//echo("func (customizeJudge *CustomizeJudge) Test21(name string) bool {\n\tif name == \"songjiang\" {\n\t\t return true\n\t}\n\treturn false\n}")

	//types := []string{
	//	"uint",
	//	"uint8",
	//	"uint16",
	//	"uint32",
	//	"uint64",
	//	"int",
	//	"int8",
	//	"int16",
	//	"int32",
	//	"int64",
	//	"float32",
	//	"float64",
	//}
	//
	//helpers := []struct {
	//	name, op        string
	//	noFloat, string bool
	//}{
	//	{
	//		name:   "equal",
	//		op:     "==",
	//		string: true,
	//	},
	//	{
	//		name:   "less",
	//		op:     "<",
	//		string: true,
	//	},
	//	{
	//		name:   "more",
	//		op:     ">",
	//		string: true,
	//	},
	//	{
	//		name:   "lessOrEqual",
	//		op:     "<=",
	//		string: true,
	//	},
	//	{
	//		name:   "moreOrEqual",
	//		op:     ">=",
	//		string: true,
	//	},
	//	{
	//		name:   "add",
	//		op:     "+",
	//		string: true,
	//	},
	//	{
	//		name: "subtract",
	//		op:   "-",
	//	},
	//	{
	//		name: "multiply",
	//		op:   "*",
	//	},
	//	{
	//		name: "divide",
	//		op:   "/",
	//	},
	//	{
	//		name:    "modulo",
	//		op:      "%",
	//		noFloat: true,
	//	},
	//}
	//
	//for _, helper := range helpers {
	//	name := helper.name
	//	op := helper.op
	//	echo(`func %v(a, b interface{}) interface{} {`, name)
	//	echo(`switch x := a.(type) {`)
	//	for i, a := range types {
	//		if helper.noFloat && strings.HasPrefix(a, "float") {
	//			continue
	//		}
	//		echo(`case %v:`, a)
	//		echo(`switch y := b.(type) {`)
	//		for j, b := range types {
	//			if helper.noFloat && strings.HasPrefix(b, "float") {
	//				continue
	//			}
	//			echo(`case %v:`, b)
	//			if i == j {
	//				echo(`return x %v y`, op)
	//			}
	//			if i < j {
	//				echo(`return %v(x) %v y`, b, op)
	//			}
	//			if i > j {
	//				echo(`return x %v %v(y)`, op, a)
	//			}
	//		}
	//		echo(`}`)
	//	}
	//	if helper.string {
	//		echo(`case string:`)
	//		echo(`switch y := b.(type) {`)
	//		echo(`case string: return x %v y`, op)
	//		echo(`}`)
	//	}
	//	echo(`}`)
	//	if name == "equal" {
	//		echo(`if isNil(a) && isNil(b) { return true }`)
	//		echo(`return reflect.DeepEqual(a, b)`)
	//	} else {
	//		echo(`panic(fmt.Sprintf("invalid operation: %%T %%v %%T", a, "%v", b))`, op)
	//	}
	//	echo(`}`)
	//	echo(``)
	//}

	//b, err := format.Source([]byte(data))
	//check(err)
	//err = ioutil.WriteFile("./src/expression/fun/helpers.go", b, 0644)
	//check(err)
	//
	////value := reflect.ValueOf(fun)
	////f := value.MethodByName("Test21") //通过反射获取它对应的函数，然后通过call来调用
	////fmt.Println(f.Call([]reflect.Value{reflect.ValueOf("zhou")}))
	//
	//cu := fun.CustomizeJudge{}
	//
	//value := reflect.ValueOf(&cu)
	//f := value.MethodByName("Test21") //通过反射获取它对应的函数，然后通过call来调用
	//values := f.Call([]reflect.Value{reflect.ValueOf("zhou")})
	//for _, v := range values {
	//	fmt.Println(v.Interface())
	//}

	//value := reflect.ValueOf(&cu)
	//name := runtime.FuncForPC(reflect.ValueOf(cu).Pointer()).Name()
	//fmt.Println("Name of function : " + name)
}
